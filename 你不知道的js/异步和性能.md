## 现在和将来
+ 程序分为现在执行的部分一级将来执行的部分
    + 将来执行的部分就是异步
    + 程序中将来执行的部分不一定在现在运行的部分执行完成之后就立即执行
    + console.log(obj),在控制台中输出obj对象时，可能会延时，这是I/O的异步操作引起的
+ 事件循环
    + JavaScript引擎本身所做的只不过是在需要的时候，在给定的任意时刻执行程序中的单个代码块。
    + 定时器没有把回调挂在事件循环队列中，他所做的是设定一个定时器，当定时器到时后，环境把回调放在事件循环中
    + 定时器只能保证回调函数不会再设定的时间之前执行
+ 并行线程
    + 异步是关于现在和将来的时间间隙，并行是关于能够同时发生的事情
    + 事件循环把自身的工作分成一个个任务并顺序执行，不允许对共享内存的并行访问和修改。通过分立线程中彼此合作的事件循环，并行和顺序执行剋共存
    + 完整运行
        + foo()开始运行，它的`所有代码`会在其他函数`任意代码`运行之前完成，函数执行之后不会中断，只有当前函数执行完成之后，才会执行接下来的函数
    + 竞态条件
        + 函数顺序的不确定性就是`竞态条件`，影响了程序运行的结果
+ 并发
    + 任务并发运行，滚动任务和请求任务并发运行，但是他们的事件是在事件循环队列中依次运行的
    + 非交互
        + 两个或多个进程并发交替执行事件时，如果他们不相关，没有相互影响时，不确定性是完全可以接受的。
    + 交互
        + 当并发的进程相互影响时，需要对他们的交互进行协调以避免竞态的出现
        + 另一种可能的并发交互条件有时称为竞态，或者门闩，它的特性可以描述为`只有第一名取胜`，在这里，不确定性是可以接受的，因为只有唯一的胜利者
            + 通过条件判断，当有结果时，其他任务不执行
    + 协作 -- 并发协作
        + 取得一个长期运行的进程，并将其分割成多个步骤或多批任务，使的其他并发进程有机会将自己的运算插入到事件循环队列中交替运行
        + 当ajax返回结果较多，可以分批执行
        + 使用setTimeout(0)进行异步调度
+ 任务
    + 事件循环队列，任务队列
    + 任务队列是挂在事件循环队列的每个tick之后的一个队列
        + 在事件循环的每个tick中，可能出现的异步动作不会导致一个完整的新事件添加到事件循环队列中，而会在当前tick的`任务队列`末尾添加一个任务
    + 事件循环类似于游乐园玩一个游戏排队才能继续，任务队列类似玩过了游戏后插队接着玩
    + 一个任务可能引起更多任务呗添加到同一个队列末尾
    + 任务--尽可能早的将来
    + `任务处理是在当前事件循环tick结尾处`，定时器触发是为了调度下一个事件循环tick
    + 任务处理先于定时器任务
+ 小结
    + 一旦有事件需要运行，事件循环就会运行，直至队列清空。事件循环的每一轮成为一个tick。用户交互，IO和定时器会向事件队列中加入事件。
    + 一次只能从队列中处理一个事件
    + 并发是指两个或多个事件链随时间发展交替执行
+ 网络解释
    + JavaScript中的任务分为同步任务和异步任务
        + 同步任务指的是在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务
        + 异步任务指的是不进入主线程，而进入`任务队列`的任务，只有任务队列通知主线程，某个异步任务可以执行了，该任务才会进入主线程尾部执行
    + 异步执行的运行机制如下
        + 所有同步任务都在主线程上，形成一个执行栈，
        + 主线程外存在一个任务队列，只要异步任务有了运行结果，就在任务队列中放置一个事件
        + 一旦执行栈中的所有同步任务执行完毕，系统就会读取任务队列，对应的异步任务就结束等待状态，进入执行栈，开始执行
        + 主线程不断重复上面的第三步
    + 事件和回调函数
        + 任务队列是一个事件的队列，IO设备完成一项任务，就在任务队列中添加一个事件，表示相关任务可以进入执行栈了
        + 任务队列中的事件，包括用户产生的事件，鼠标点击，页面滚动等等，只要指定过回调函数，这些事件就会进入任务队列
        + 回调函数是会被主线程挂起来的代码。异步任务必须指定回调函数
        + 主线程首先检查一下执行事件，某些事件只有到了规定的时间，才能返回主线程




## 回调
+ 在函数内部，语句以可预测的顺序执行，但在函数顺序上，事件的运行顺序有很多可能
+ continuation -- 回调函数包裹或者说封装了程序的延续
+ 顺序的大脑
    + 嵌套回调与链式回调
        + 回调方式最主要的缺陷，对于他们在代码中表达异步的方式，我们的大脑需要努力才能同步得上
+ 信任问题
    + 第三方控制下的异步
    + 控制反转，把自己程序一部分的执行控制交给某个第三方。
    + 回调最大的问题是控制反转，会导致信任链的完全断裂。
    + 回调不是很好的异步方式，存在很多问题。
        + 回调过早，回调过晚
        + 回调次数太少或太多
        + 其他
+ 省点回调
    + 分离回调--成功回调，失败回调
        + 没有涉及阻止或过滤不想要的重复调用回调的问题

## Promise
+ 通过回调表达程序异步和管理并发的两个主要缺陷
    + 缺乏顺序性和可信任性
+ Promise
    + 不把自己程序的continuation传给第三方，而是希望第三方给我们提供了解决其任务何时结束的能力，然后由我们自己的代码来决定下一步做什么
    + promise值
        + `Promise.all([promise1,peomise2])`,promise.all([]),等待数组中的所有promise完成
        + Promise的决议结果可能是拒绝而不是完成，完成值总是由编程给出，而拒绝值，通常称为拒绝原因，可能是程序逻辑直接设置的，也可能是运行异常隐式得出的值
        + Promise调用then可以传递两个参数，一个是完成回调，一个是拒绝回调
        + 一旦Promise决议，有了结果，这个结果是不可变得
        + Promise可以按照可预测的方式组合，而不用关心时序或底层的结果
    + 完成事件
        + 通过某种方式在任务完成时得到通知，对通知的序曲重新组织为对任务发出的一个完成事件的侦听
        + `回调方式`--任务调用回调，`Promise方式`--侦听来自任务的事件，得到通知，根据情况继续
        + 事件完成后，构造一个`事件订阅处理对象`并返回，实现反控制反转,返回的监听对象就是分离的关注点之间一个中立的第三方协商机制
        + Promise事件返回一个Promise对象，该对象通过then注册一个then事件，包括成功事件和拒绝事件
        + Promise中的函数会立即执行，调用的then()中的回调会异步延迟，有两个参数，resolve 事件和 reject 事件
        + `Promise的结果不变`,resolve不能变为reject，reject也不能变为resolve
+ 具有then方法的鸭子类型
    + 如何识别和判断类似Promise的值是否是真正的Promise很重要
    + 将Promise定义为任何具有then()方法的对象和函数
+ Promise信任问题
    + 调用过早
        + 对一个promise调用then()的时候，即使这个promise已经决议，提供给then()的回调也总会被异步调用
    + 调用过晚
        + 一个promise决议后，这个promise上所有的通过then()注册的回调都会在下一个异步时机点上依次被立即调用，这些回调的任意一个都无法影响或延误对其他回调的调用
    + promise调度技巧
        + promise决议后使用了另一个promise，作为决议结果的 promis 还是异步的
    + 回调未调用
        + 没有任何东西能阻止promise向你通知它的决议，一个promise注册了resolve和reject，promise决议后总是会调用其中一个
        + promise竞态,防止promise永远不决议的情况
            + `Promise.race([foo(),promise])`，两个promsie，`谁先完成执行哪个`，第二个promise设定定时器，第一个promise未在规定事件内执行，第二个promise执行
    + 调用次数过少或过多
        + promise只能决议一次或者0次，试图多次调用时，promise只会接受第一次决议，并忽略任何后续调用
    + 未能传递参数/环境值
        + promise至多只能有一个决议值
        + 如果没有任何值显示决议，这个值就是undefined
        + 如果使用多个参数调用resolve()或者reject()，第一个参数之后的所有参数都会被默默忽略。
        + 如果要传递多个值，必须把他们封装在单个值中传递
    + 吞掉错误或异常
        + 如果拒绝一个promise并给出一个理由，这个值就会传给拒绝回调
        + 如果在promise的创建过程中或在查看器决议结果过程中的任何时间点出现了一个JavaScript异常，异常被捕获导致promise被拒绝
        + 当promise完成决议，但在查看结果时（then注册的回调）出现JavaScript异常，执行到异常语句代码结束，异常不抛出，`因为promise决议不会改变`，决议成功了所以不报错
    + 是可信任的promise吗
        + promise并没有完全摆脱回调，它们只是改变了传递回调的位置
        + `Promise.resolve()`,如果向Promise.resolve()传递一个非Promise，非thenable的立即值，就回得到用这个值填充的promise，如果向它传递一个promise，则返回这个promise，如果传递一个非promise的thenable值，方法试图展开这个值，展开过程持续到提取出一个具体的非类promise的最终值
        + Promise.resolve()为所有函数的返回值都封装一层。这样做很容易把函数调用规范为定义良好的异步任务。
    + 建立信任
+ 链式流
    + promise固有特性
        + 每次对promise调用then(),他都会`创建并返回一个新的promise`，可以将其链接起来，链式调用
        + 不管从then()调用的`完成回调`resolve返回的值是什么，他都会自动设置为被链接promise的完成，也就是返回值被传递给下一个promise的resolve函数
        + 在完成或拒绝处理函数内部，如果返回一个值或抛出一个异常，新返回的Promise就相应地决议
        + 如果完成或拒绝处理函数返回一个promise，它将会被展开，不管它的决议值是什么，都会成为当前then()返回的链接Promise的`决议值`( resolve 或 reject )。
    + 从完成处理函数返回 thenable 或者 promise 时会将展开接收到的值并递归的前进
    + 在链式then()中，下一个then()调用依赖于上一个then()的返回值，会等待上个then()的异步任务
    + 调用then()时的完成处理函数或拒绝处理函数如果抛出异常，都会导致链中的下一个promise因为这个异常而立即被拒绝
    + 调用then()抛出异常，代码跳到链中下一个promise并执行reject函数
    + 术语，决议、完成以及拒绝
        + promise的第一个参数回调会展开 thenable 和 真正的promise ，即使thenable中是一个reject函数，它的功能和Promise.resolve() 一样
        + 决议 --- Promise返回的状态，是完成还是拒绝称作决议
        + `var p = new Promise( function(resolve, reject){} )`
            + promise的第一个参数命名为resolve，第二个参数命名为reject
        + `then(fulfilled(),rejected())`
            + then第一个参数命名为fulfilled，第二个参数命名为rejected
+ 错误处理
    + try..catch 无法跨异步操作
    + promise执行resolve过程中，resolve中的代码出现异常，如果该promise之后没有包含reject的then调用，错误被吞掉
        + `var p = Promise.resolve(42);p.then(function fulfilled(msg){consolog.log(msg.toLowerCase())},function rejected(){})`  ,resolve中 数字没有toLowerCase()方法， 报错，但是reject不能处理这个错误，因为reject是P的拒绝处理函数，此时p的决议是resolve的，无法改变，所以reject无法调用，resolve中报错，错误被吞掉，若p.then()之后还有一个then()调用，这个错误会被传递给它的reject()
    + 绝望的陷阱
        + catch返回的也是promise，永远无法确定链式调用最底端会不会报错，永远无法处理最底端的报错
    + 处理未捕获的情况
        + 在链式调用底端以done()结束，done不会返回promise，done拒绝处理函数捕获了链式调用中可能的错误，而函数本身中的任何异常都会被作为一个全局未处理错误抛出
    + 成功的坑
        + 默认情况下，Promise在下一个任务或事件循环上报告所有拒绝，如果在这个时间点上该Promise上还没有注册错误处理函数
        + 如果想要一个被拒绝的Promise在查看之前的某个时间段内保持被拒绝状态，可以调用defer()，这个函数优先级高于该Promise的自动错误报告
        + 如果一个Promise被拒绝，默认情况会向开发者终端报告这个事实，可以选择隐式(reject)或者显示(defer)禁止报告
+ Promise模式
    + Promise.all([])
        + 参数是一个由多个promise实例组成的数组，返回一个promise，这个promise只有在all中的所有promise都完成之后才决议为resolve，只要一个拒绝，主promise就拒绝，`主promise完成时返回的是一个结果数组`，按参数顺序存放各promise的结果值
        + `传入空数组`，主Promise 立即完成
    + Promise.race([])
        + 一旦有任何一个Promise决议完成，它就完成；任何一个拒绝，他就拒绝
        + 只关注第一个决议的Promsie
        + 如果传入空数组,主Promise永远不会决议，会被挂起
        + 超时竞赛
            + 给某个Promise设定超时时间，超时未决议，主promse拒绝
                + Promise.race([promise,settimeout])
        + finally
            + finally在promise决议后总是会被调用，不论promise完成或是拒绝
            + Promise.observe()用来查看Promise的决议
    + all 和 race 的变体
        + none([]) ,所有promise都被拒绝，主promise完成，有一个完成，主promise拒绝
        + any([]), 忽略拒绝，只要有一个promise完成，主promise完成
        + first([]),只关注第一个完成的promise
        + last([]),只关注最后一个完成的promise
    + 并发迭代
        + Promise.map()
+ Promise概述
    + new Promise()构造器
        + new Promise(function(resolve,reject){}),promsie必须和new一起使用，并且必须提供一个函数回调，这个函数接收两个回调函数，resolve，reject
    + Promise.resolve() ,  Promise.reject() 
        + 创建已完成的promsie，和拒绝的promise的快捷方式
    + then() 和 catch()
        + then() 和 catch() 不会同时被调用
        + then接收一个或两个参数，第一个用于完成回调，第二个拒绝回调，省略其中一个会被替换为相应的默认回调，默认完成把消息传递下去，默认拒绝重新抛出接收到的出错原因
        + catch接收一个拒绝回调，自动替换默认完成回调，等价于then(null,...)
        + `完成或拒绝回调`（promise已经决议，无法更改）中抛出异常，返回的promise是被拒绝的，如果返回非Promise，非thenable的立即值，这个值会用做返回promise的完成值，如果完成处理函数返回一个promise或thenable，这个值会被展开，并作为promise的决议值
    + Promise.all() 和 Promise.race()
        + all()全部完成，返回完成，一个拒绝，返回拒绝，完成得到数组，包含所有promise的完成值，按promise的传入顺序排列
        + race()只关注第一个决议的promise，忽略后续promise
+ Promise局限性
    + 顺序错误处理 
        + promise链中的错误很容易被无意中默默忽略掉
    + 单一值
        + Promise只能有一个完成值或一个拒绝理由
        + 分裂值
            + 当promise返回的是两个值时，可以将两个值都封装成 promise 对象，通过 Promise.all() 获取两个promise的返回值
        + 展开/传递参数
            + 数组解构 `function([x,y]){console.log(x,y)}`
    + 单决议
        + Promise最本质的一个特征，Promise只能被决议一次
    + 惯性
        + 把需要回调的函数封装成为支持Promise的函数，这个动作有时被称为"提升"或者"Promise工厂化"
    + 无法取消的Promise
        + 单独的Promise不应该被取消，但是取消一个Promise序列是合理的
    + 性能
+ 小结
    + Promise very good！
    + 解决了回调的控制反转问题
    + 将回调的安排转交给了一个位于我们和其他工具之间的可信任的中介机制
    + Promise链提供以顺序的方式表达异步流

## 生成器
    +