## 作用域

- 用来存储变量，并且以后可以方便的找到这些变量的良好规则

* 编译阶段三步骤

  - 分词和词法分析
    - 分词，将代码分为片段==`var a=2;`,var，a,=,2,;
    * 词法分析，判断 a 是否是独立，还是其他词法单元的一部分，判断类型

  * 解析/语法分析
    - 将词法单元六转换成一个由元素逐级嵌套的代表程序语法结构的树
      - var a =2 ;
        - var 顶节点 VariavleDeclaration
          - Identifier a
          - AssignmentExperession =
            - NumericLiteral 2

  - 代码生成

* js 代码执行
  - 引擎，负责整个程序的编译和执行
  - 编译器，负责语法分析及代码生成
  - 作用域，负责收集并维护由所有声明的标识符组成的一系列查询

- 代码执行过程`var a=2`
  - 遇到`var a`编译器询问作用域是否有`a`名称的变量在作用域中，有忽略，没有创建
  - 编译器为引擎生成运行时所需要的代码
  - 引擎运行询问作用域有没有`a`变量存在，有运行赋值语句，没有继续查找，找不到抛出异常

* `a=2`LHS 查询和 RHS 查询，赋值标识符左右查询
  - LHS 查询试图找到变量的容器
  - RHS 查询试图找到某个变量的值
  * 赋值操作执行 LHS 查询，引用值时执行 RHS 查询

- 栈内存和堆内存
  - 基本数据类型的值存放在栈内存中
  - 复杂数据类型的值存放在堆内存中
    - 复杂数据类型的引用地址存放在栈内存中
  * let a=2 执行过程
    - 创建一个值 2 放入栈中，再创建一个变量 a，将变量 a 和值 2 关联起来
  - 一个变量只能关联一个值，一个值可以关联多个变量，b={1},a={1},b={2},此时 b 关联 {2}

* 变量提升
  - 用 var 声明的变量和函数表达式会被提升到当前作用域的顶部
    - 未用 var 声明的变量会会生成全局变量，但不会提升
    * 函数提升优先级高于变量提升，且不会被同名变量声明覆盖，但是会被变量赋值后覆盖。而且存在同名函数与同名变量时，优先执行函数。

## 词法作用域

- 全局变量自动变为全局对象 window 的属性，通过 window.a 来访问杯同名变量遮蔽的变量，非全局变量被遮蔽无论如何也访问不到

* 函数的作用域只由函数被声明时所处的位置决定

### 欺骗词法

- eval()
  - eval("var b=2;"),将代码写入函数中，相当于在函数中执行了，var b=2;语句
  * eval()通常用来执行动态创建的代码，eval(str),str 为根据环境动态生成的代码
  - 严格模式下不能使用

* with()，通常被当作重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身
  - with()将一个对象处理为一个完全隔离的词法作用域，对象的属性被处理为作用域中的变量，在 with 中执行赋值操作，跟在其他作用域一样，a=2，执行 LHS 查询，有则赋值，没有创建全局变量

- 编译的词法分析阶段基本能够知道全部标识符在哪里以及是如何声明的

## 函数作用域和块作用域--任何声明在某个作用域内的变量，都将附属于这个作用域

- 每个函数都会为其自身创建一个作用于气泡，其他结构不会创建
  - for 循环和 if 语句没有自己的作用域
  * 每个作用域气泡中的标识符只能在当前作用域和嵌套的作用域中访问，在外部作用域不能访问

* 将代码封装在函数中，可以隐藏内部实现，在函数作用域外部访问不到函数内部实现
  - 封装函数标识符会污染全局作用域，必须通过调用函数执行

- 函数声明和函数表达式
  - 区分函数声明和函数表达式的方法是看 function 关键字的位置
  * 匿名函数和具名函数---名称标识符
    - 匿名函数缺点
      - 调用栈中不会显示出有意义的函数名，调试困难
      * 无法引用自身，递归或者是解绑监听器
      * 代码可读性不强
  - 立即执行函数，IIFE，(immediately invoked function expression)
    - (function(){})()
      - 函数被包在()内部，因此成为了一个表达式，再通过()来调用
    - (function(){}())

* 块作用域
  - let const，声明的变量不会提升
    - 垃圾回收 {let a=1},代码执行后将{}中的代码垃圾回收
  * try/catch 的 cathc 分支内的变量
  - with
+ 命名空间
  + 一个对象即为一个命名空间
    + a.b,a.a,b.b,b.a
    + 不同对象中可以使用相同的属性名
## 提升
+ `var a=2;`,在编译器看来等于  var a,a=2;
  + 在编译阶段，编译器会将所有声明提前处理，变量提升
  + 函数声明会提升，函数表达式不会提升
  + 函数声明的优先级高，比变量声明高
  + 避免重复声明，变量声明会被同名函数声明覆盖，同名函数声明会覆盖前面的函数声明
  

## 作用域闭包
+ 闭包
  + 当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。
    + 两个作用域：函数作用域，函数所在作用域
    + 无论通过什么手段将`内部函数`传递到所在词法作用域以外，他都会持有对原始定义作用域的引用，无论在何时执行这个函数都会使用闭包
    + 本质上，无论何时何地将函数作为第一级的值类型进行传递，就产生了闭包，`回调函数`
+ 循环和闭包
  + 循环中定义定时器，没有块作用域，使用的是同一个作用域，延时函数调用，延迟函数附属同一个作用域
  + 变量劫持，块级作用域，let声明
+ 模块
  + 闭包的应用
  + 返回具有局内函数引用的对象，通过对象属性调用函数，访问函数内部作用域及函数，更改内部变量
  + 使用立即执行函数创建模块，`var mymodule=(function(){})()`,函数只执行一次，不会重复创建模块实例
  + 模块机制
    + 现代的
     + 一个按名字存储函数引用的对象
     + 一个数组控制某个函数对外部函数的依赖
    + 未来的，export，import
  + 模块特征
    + 为创建内部作用域而调用了一个包装函数
    + 包装函数的返回值必须至少包括一个对内部函数的引用-- `创建涵盖整个内部作用域的闭包`